# 05. 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?

- 상태는 어떠한 의미를 지닌 값이면 어플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다
- UI : 상호 작용이 가능한 모든 요소의 현재 값
- URL : 브라우저에 의해 관리되고 있는 상태 값
- Form: 폼의 상태, 로딩 / 제출 / 접근 가능여부 / 값의 유효성
- 서버에서 가져온 값

### 5.1.1 리액트 상태 관리의 역사

#### Flux 패턴의 등장

- 리액트로 작성 된 어플리케이션의 크기가 방대해짐에 따라 상태를 관리 추적하는 것에 어려움이 발생
- 페이스북 팀은 상태 관리 어려움의 원인을 양방향 데이터 바인딩이라고 보고, 단방향으로 데이터 흐름을 변경하는 것을 제안하는데 이것이 바로 Flux 패턴이다
- Action -> Dispatcher -> Store -> View 의 방향
- 이러한 단방향 흐름은 상태의 관리 및 추적에는 유리했지만, 사용자의 입력에 따라 데이터를 갱신하고 화면을 업데이트 하는 코드도 추가가 되는 불편함이 존재

#### 시장 지배자 리덕스의 등장

- 리덕스는 Flux 구조에 Elm 아키텍쳐를 도입하여 시장을 지배
- Elm 은 데이터를 Model, View, Update 라는 단방향 흐름으로 강제하여 어플리케이션의 상태를 안정적으로 관리
- 다만 해당 기능을 사용하기 위해 많은 보일러 플레이트 코드가 필요하다는 단점이 존재

#### Context API 와 useContext

- Props Drilling 등의 문제 해결을 위해 16.3 버전에서 Context API 를 출시

#### 훅의 탄생, 그리고 React Query 와 SWR

- 16.8 버전에서 함수 컴포넌트에 사용 가능한 훅 API 를 추가
- 훅으로 인하여 state 관리가 단순화 되어 React Query 와 SWR 라는 통신 요청에 특화된 상태 관리 라이브러리가 탄생
- 리덕스에 비해 보일러 플레이트 코드를 줄일 수 있는 장점이 존재

#### Recoil, Zustand, Jotai, Valtio 에 이르기까지

- 리덕스에 이어 훅을 이용하여 작은 크기의 상태를 효율적으로 관리하는 상태관리 라이브러리가 탄생

### 5.1.2 정리

## 5.2 리액트 훅으로 시작하는 상태 관리

### 5.2.1 가장 기본적인 방법: useState 와 useReducer

- useState 와 useReducer 를 사용하면 간단한 상태 관리가 가능
- 하지만 훅을 사용할 때 마다 컴포넌트 별로 초기화 되므로 컴포넌트 별로 다른 상태를 가지게 되어, 해당 컴포넌트에서만 상태가 유효하다는 한계점이 존재
- 아래와 같이 상태를 한단계 끌어올리는 방법이 존재하지만, 상태를 자식에게 props 로 전달해야하는 불편함이 발생

```jsx
function Counter1({ counter, inc }: { counter: number, inc: () => void }) {
  return (
    <>
      <h3>Counter1: {counter}</h3>
      <button onClick={inc}>+</button>
    </>
  );
}

function Counter2({ counter, inc }: { counter: number, inc: () => void }) {
  return (
    <>
      <h3>Counter2: {counter}</h3>
      <button onClick={inc}>+</button>
    </>
  );
}

function Parent() {
  const { counter, inc } = useCounter();
  return (
    <>
      <Counter1 counter={counter} inc={inc} />
      <Counter2 counter={counter} inc={inc} />
    </>
  );
}
```

### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

- 상태를 클로저에 맡기는 것이 아니라, JS 실행 문맥 내에서 초기화가 가능하도록 분리해보기

```tsx
// counter.ts
export type State = { counter: number };

// 상태를 아예 컴포넌트 밖에 선언했다. 각 컴포넌트가 이 상태를 바라보게 할 것이다.
let state: State = { counter: 0 };

// getter
export function get(): State {
  return state;
}

// useState와 동일하게 구현하기 위해 게으른 초기화 함수나 값을 받을 수 있게 했다.
type Initializer<T> = T extends any ? T | ((prev: T) => T) : never;

// setter
export function set<T>(nextState: Initializer<T>) {
  state = typeof nextState === "function" ? nextState(state) : nextState;
}

// Counter
function Counter() {
  const state = get();

  function handleClick() {
    set((prev: State) => ({ counter: prev.counter + 1 }));
  }

  return (
    <>
      <h3>{state.counter}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- 하지만 해당 코드는 상태값의 변경은 정상적으로 작동되나 컴포넌트가 리렌더링되지 않아 문제가 발생한다
- 해당 문제를 해결하기 위해, 외부 state 값을 컴포넌트 내부의 useState 의 인수로 전달하는 방식으로 해결

```tsx
function Counter1() {
  const [count, setScount] = useState(state);

  function handleClick() {
    // 외부에서 선언한 set 함수 내부에서 다음 상태값을 연산한 다음, 그 값을 로컬 상태값에도 넣기
    set((prev: State) => {
      const newState = { counter: prev.counter + 1 };
      // setCount 의 호출로 리렌더링 발생
      setCount(newState);
      // return 으로 업데이트 된 상태값을 외부 상태에 반영
      return newState;
    });
  }

  return (
    <>
      {/* 컴포넌트 내부의 state 인 count 사용 */}
      <h3>{count.counter}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- 위와 같은 코드는 작동은 하지만 외부에서 관리하는 state 를 다시 컴포넌트 내부에서 state 로 선언하여 사용하는 등의 문제가 발생한다
- 또한, 액션이 발생한 컴포넌트는 리렌더링이 발생하지만 다른 컴포넌트에서 외부 상태값을 참조하고 있을 경우 해당 컴포넌트는 다시 렌더링이 발생하기 전까지는 변경된 상태값 적용이 안된다
- 이를 해결하기 위해서는 별도의 기능을 하는 createStore, useStore 등의 코드를 만들어서 사용해야만 한다
- 이와 비슷한 기능은 React 의 useSubscription 을 통해 구현되어 있다

\*\* [p. 367] 이거 코드 길게 잘 써놨는데.... 흐음 애매하네요 ㅎㅎㅎ
\*\* 막상 리덕스는 알알려주는....

### 5.2.3 useState 와 Context를 동시에 사용해 보기
