# CH1. 리액트 개발을 위해 꼭 알아야할 자바스크립트

## 1.1 자바스크립트의 동등 비교

### 1.1.1 JS의 데이터 타입

- 원시 타입

  - boolean
  - null
    - 명시적으로 비어 있는 값
    - type of 의 결과는 object 가 나온다
  - undefined
    - 선언 되었으나 할당되지 않은 값
  - number
    - 최대 2^53 - 1 까지 표현 가능
  - bigint
    - 2^53 - 1 이상의 수 표현 가능
  - string
  - symbol
    - 중복되지 않는 고유한 값, 함수로만 생성 가능

```js
const key1 = Symbol("key");
const key2 = Symbol("key");

key1 === key2; //false

// 동일한 값을 위해서넌 Symbol.for 사용
```

\*\* [p.26] Symbor 은 언제 쓰일까? 그리고 Symbor.for 로 동일한 값을 사용하면 그냥 일반 값을 쓰는 것과 무슨 차이일까?

- 객체 타입

  - object
  - 참조를 전달하기 때문에 참조 타입(reference type)으로 불리운다

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 차이

  - 원시 타입은 메모리에 값 자체를 저장
  - 객체 타입은 프로퍼티를 수정할 수 있으므로 원시 타입과 다르게 변경 가능한 형태로 저장, 값을 복사 할 때도 참조 값이 복사
  - 단, 객체 내부의 프로퍼티의 값은 원시 형태로 저장

### 1.1.3 자바스크립트의 또다른 비교 공식 Object.is

- ES6(2015)에 도입 된 비교 문법, === 의 한계를 극복하기 위해 도입
- === 와 동일하게 자동 형변환을 하지 않고 비교
- === 가 하지 못하는 비교 가능
- 객체간의 비교는 === 와 동일하게 비교

```js
-0 === +0; // true
Object.is(-0, +0); //false
// (x !== 0 || 1 / x === 1 / y) 를 사용해서 구분

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true
// (x !== x && y !== y) 를 이용해 구분

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
// (x !== x && y !== y) 를 이용해 구분
```

\*\* [p.29] 이게 리얼루다가 제정신인 언어냐......

### 1.1.4 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 Object.is 를 사용
- ES6 하위 호환을 위해 별도로 구현한 polyfill(이전 브라우저에서 최신 기능 사용을 위한 코드) 사용

- 리액트에서 아용하는 비교 코드

- TS 버전

```ts
// polyfill
function is(x: any, y: any) {
  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
}

// 일반
const objectIs: (x: any, y: any) => boolean =
  typeof Object.is === "function" ? Object.is : is;
```

- JS 버전

```js
// polyfill
function is(x, y) {
  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
}

// 일반
const objectIs = typeof Object.is === "function" ? Object.is : is;

const obj1 = {};
const obj2 = {};

const objCopy = obj1;

console.log(is(obj1, obj2)); // false
console.log(is(obj1, objCopy)); // true

console.log(objectIs(obj1, obj2)); // false
console.log(objectIs(obj1, objCopy)); // true
```

\*\* [p. 29] -0 과 +0의 비교와 NaN이 각기 다르다는 점을 명확히 이해하게 되어서, 추후에 이게 왜이러지? 하는 상황은 거의 없긴 하겠지만 피할 수 있을듯
<br>
\*\* 그런데 이러니 JS가 노근본이라 욕을 먹지......

```js
// 전체 수식
if (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);

// 첫번째 수식
if (x === y)

// 두번째 수식
if (x !== 0 || 1 / x === 1 / y)

// 세번째 수식
if (x !== x && y !== y)
```

- 먼저 첫번째 비교식으로 기본적인 JS의 비교 성립

---

- 두번째 비교식(x !== 0 || 1 / x === 1 / y)을 통해 -0 과 +0 을 비교 가능
- -0, +0 은 0 과 같다고 판단 되므로 x !== 0 에서 false 해당 비교식은 OR(||) 로 연결되어 있으니 다음 비교식 진행
- 1 / x 와 1 / y 는 각각 부호가 붙은 인피니티가 나오기 때문에 서로 다르다! 따라서 해당 비교식에서 false
- 그럼 두번째 비교식이 둘 다 false 처리가 되므로 해당 비교식은 false -> 전체 비교문은 AND(&&) 로 처리 되어 있으므로 false 결과 반환

---

- 세번째 비교식(x !== x && y !== y)을 통해 NaN 이 동등하다는 비교가 가능
- NaN은 특이한 성질을 같는데, NaN은 JS의 전역 Number 객체의 프로퍼티다. 그리고 서로 동일 비교를 하면 false 가 뜬다
- 따라서 NaN 끼리는 동등 비교를 통해 true 를 도출 할 수 없다
- 이를 해결하기 위해 NaN이 세번째 비교식에 들어가면 둘다 true 가 뜨므로 다양한 NaN 이 동등하다고 비교가 가능하다
- 추가 isNaN() 과 Number.isNaN() 의 차이
  - isNaN은 인자를 숫자로 일단 한번 변환을 시킨 후, 해당 값이 NaN이면 true -> 문자열이나 숫자 이외의 값을 true 처리
  - Number.isNaN은 변환 과정 없이 인자가 정확히 NaN 인 경우만 true 처리

### 1.1.4 리액트에서의 동등 비교

- 리액트는 일단 Object.is 로 동등 비교를 한다
- 동등 비교가 안되는 객체의 경우는 depth 1 까지만 동등 비교(얕은 비교)를 한다
- 이로 인해서 객체가 depth 2 이상을 가지게 되면, 값이 변화하지 않아도 무조건 렌더링이 되는 문제 발생
  - useState 에서 객체를 잘 못 전달하면 무한 렌더링이 발생하는 이슈도 이러한 비교 특성으로 인한 문제
- 재귀를 활용해서 객체를 깊은 비교를 했다면?
  - 성능 이슈가 발생할 가능성이 높아서 제외
  - 잘못된 객체 하나로 인하여 페이지 자체가 멈춰버리는 현상 발생 -> 프론트 입장에서는 최악의 결과

```js
import { memo, useEffect, useState } from "react";

type Props = {
  counter: number,
};

const Component = memo((props: Props) => {
  useEffect(() => {
    console.log("Component 랜더!");
  });

  return <h1>{props.counter}</h1>;
});

// Depth 가 2 이상이므로 memo 가 역할을 하지 못하고 무조건 렌더링이 된다.
type DeeperProps = {
  counter: {
    counter: number,
  },
};

const DeeperComponent = memo((props: DeeperProps) => {
  useEffect(() => {
    console.log("DeeperComponent 랜더!");
  });

  return <h1>{props.counter?.counter}</h1>;
});

export default function Chapter01() {
  const [, setCounter] = useState(0);

  const handleClick = () => {
    setCounter((prev) => prev + 1);
  };

  return (
    <div>
      <Component counter={100} />
      <DeeperComponent counter={{ counter: 100 }} />
      <button onClick={handleClick}>리렌더</button>
    </div>
  );
}
```

### 1.1.5 정리

- JS의 이러한 언어적 특성(=한계) 이해해야만 정확한 리액트 구현이 가능
- 추후 의존성 배열, useMemo, useCallback, React.memo 에도 동일하게 적용 되므로 이를 바탕으로 최적화 가능
