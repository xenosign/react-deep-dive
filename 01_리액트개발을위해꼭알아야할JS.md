# CH1. 리액트 개발을 위해 꼭 알아야할 자바스크립트

## 1.1 자바스크립트의 동등 비교

### 1.1.1 JS의 데이터 타입

- 원시 타입

  - boolean
  - null
    - 명시적으로 비어 있는 값
    - type of 의 결과는 object 가 나온다
  - undefined
    - 선언 되었으나 할당되지 않은 값
  - number
    - 최대 2^53 - 1 까지 표현 가능
  - bigint
    - 2^53 - 1 이상의 수 표현 가능
  - string
  - symbol
    - 중복되지 않는 고유한 값, 함수로만 생성 가능

```js
const key1 = Symbol("key");
const key2 = Symbol("key");

key1 === key2; //false

// 동일한 값을 위해서넌 Symbol.for 사용
```

\*\* [p.26] Symbor 은 언제 쓰일까? 그리고 Symbor.for 로 동일한 값을 사용하면 그냥 일반 값을 쓰는 것과 무슨 차이일까?

- 객체 타입

  - object
  - 참조를 전달하기 때문에 참조 타입(reference type)으로 불리운다

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 차이

  - 원시 타입은 메모리에 값 자체를 저장
  - 객체 타입은 프로퍼티를 수정할 수 있으므로 원시 타입과 다르게 변경 가능한 형태로 저장, 값을 복사 할 때도 참조 값이 복사
  - 단, 객체 내부의 프로퍼티의 값은 원시 형태로 저장

### 1.1.3 자바스크립트의 또다른 비교 공식 Object.is

- ES6(2015)에 도입 된 비교 문법, === 의 한계를 극복하기 위해 도입
- === 와 동일하게 자동 형변환을 하지 않고 비교
- === 가 하지 못하는 비교 가능
- 객체간의 비교는 === 와 동일하게 비교

```js
-0 === +0; // true
Object.is(-0, +0); //false
// (x !== 0 || 1 / x === 1 / y) 를 사용해서 구분

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true
// (x !== x && y !== y) 를 이용해 구분

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
// (x !== x && y !== y) 를 이용해 구분
```

\*\* [p.29] 이게 리얼루다가 제정신인 언어냐......

### 1.1.4 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 Object.is 를 사용
- ES6 하위 호환을 위해 별도로 구현한 polyfill(이전 브라우저에서 최신 기능 사용을 위한 코드) 사용

- 리액트에서 아용하는 비교 코드

- TS 버전

```ts
// polyfill
function is(x: any, y: any) {
  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
}

// 일반
const objectIs: (x: any, y: any) => boolean =
  typeof Object.is === "function" ? Object.is : is;
```

- JS 버전

```js
// polyfill
function is(x, y) {
  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
}

// 일반
const objectIs = typeof Object.is === "function" ? Object.is : is;

const obj1 = {};
const obj2 = {};

const objCopy = obj1;

console.log(is(obj1, obj2)); // false
console.log(is(obj1, objCopy)); // true

console.log(objectIs(obj1, obj2)); // false
console.log(objectIs(obj1, objCopy)); // true
```

\*\* [p. 29] -0 과 +0의 비교와 NaN이 각기 다르다는 점을 명확히 이해하게 되어서, 추후에 이게 왜이러지? 하는 상황은 거의 없긴 하겠지만 피할 수 있을듯
<br>
\*\* 그런데 이러니 JS가 노근본이라 욕을 먹지......

```js
// 전체 수식
if (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);

// 첫번째 수식
if (x === y)

// 두번째 수식
if (x !== 0 || 1 / x === 1 / y)

// 세번째 수식
if (x !== x && y !== y)
```

- 먼저 첫번째 비교식으로 기본적인 JS의 비교 성립

---

- 두번째 비교식(x !== 0 || 1 / x === 1 / y)을 통해 -0 과 +0 을 비교 가능
- -0, +0 은 0 과 같다고 판단 되므로 x !== 0 에서 false 해당 비교식은 OR(||) 로 연결되어 있으니 다음 비교식 진행
- 1 / x 와 1 / y 는 각각 부호가 붙은 인피니티가 나오기 때문에 서로 다르다! 따라서 해당 비교식에서 false
- 그럼 두번째 비교식이 둘 다 false 처리가 되므로 해당 비교식은 false -> 전체 비교문은 AND(&&) 로 처리 되어 있으므로 false 결과 반환

---

- 세번째 비교식(x !== x && y !== y)을 통해 NaN 이 동등하다는 비교가 가능
- NaN은 특이한 성질을 같는데, NaN은 JS의 전역 Number 객체의 프로퍼티다. 그리고 서로 동일 비교를 하면 false 가 뜬다
- 따라서 NaN 끼리는 동등 비교를 통해 true 를 도출 할 수 없다
- 이를 해결하기 위해 NaN이 세번째 비교식에 들어가면 둘다 true 가 뜨므로 다양한 NaN 이 동등하다고 비교가 가능하다
- 추가 isNaN() 과 Number.isNaN() 의 차이
  - isNaN은 인자를 숫자로 일단 한번 변환을 시킨 후, 해당 값이 NaN이면 true -> 문자열이나 숫자 이외의 값을 true 처리
  - Number.isNaN은 변환 과정 없이 인자가 정확히 NaN 인 경우만 true 처리

### 1.1.4 리액트에서의 동등 비교

- 리액트는 일단 Object.is 로 동등 비교를 한다
- 동등 비교가 안되는 객체의 경우는 depth 1 까지만 동등 비교(얕은 비교)를 한다
- 이로 인해서 객체가 depth 2 이상을 가지게 되면, 값이 변화하지 않아도 무조건 렌더링이 되는 문제 발생
  - useState 에서 객체를 잘 못 전달하면 무한 렌더링이 발생하는 이슈도 이러한 비교 특성으로 인한 문제
- 재귀를 활용해서 객체를 깊은 비교를 했다면?
  - 성능 이슈가 발생할 가능성이 높아서 제외
  - 잘못된 객체 하나로 인하여 페이지 자체가 멈춰버리는 현상 발생 -> 프론트 입장에서는 최악의 결과

```js
import { memo, useEffect, useState } from "react";

type Props = {
  counter: number,
};

const Component = memo((props: Props) => {
  useEffect(() => {
    console.log("Component 랜더!");
  });

  return <h1>{props.counter}</h1>;
});

// Depth 가 2 이상이므로 memo 가 역할을 하지 못하고 무조건 렌더링이 된다.
type DeeperProps = {
  counter: {
    counter: number,
  },
};

const DeeperComponent = memo((props: DeeperProps) => {
  useEffect(() => {
    console.log("DeeperComponent 랜더!");
  });

  return <h1>{props.counter?.counter}</h1>;
});

export default function Chapter01() {
  const [, setCounter] = useState(0);

  const handleClick = () => {
    setCounter((prev) => prev + 1);
  };

  return (
    <div>
      <Component counter={100} />
      <DeeperComponent counter={{ counter: 100 }} />
      <button onClick={handleClick}>리렌더</button>
    </div>
  );
}
```

### 1.1.5 정리

- JS의 이러한 언어적 특성(=한계) 이해해야만 정확한 리액트 구현이 가능
- 추후 의존성 배열, useMemo, useCallback, React.memo 에도 동일하게 적용 되므로 이를 바탕으로 최적화 가능

## 1.2 함수

### 1.2.1 함수란 무엇인가?

- 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감사서 실행 단위로 만들어 놓은 것

### 1.2.2 함수를 정의하는 4가지 방법

#### 함수 선언문

- 가장 일반적인 방식
- 선언문은 표현식이 아니므로 변수에 할당이 불가능해 보이지만, JS 엔진이 자동으로 표현식으로 해석하여 할당 가능
- 호이스팅 지원

```js
const sum = function sum(a, b) {
  return a + b;
};
```

### 함수 표현식

- JS에서 함수는 일급 객체(= 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체)이다
- 따라서 함수는 다른 함수의 매개변수, 반환 값으로 사용이 가능
- 혼란을 방지하기 위해 함수의 이름은 생략하여 사용
- 호이스팅 미지원

```js
const sum = function (a, b) {
  return a + b;
};
```

\*\* [p. 39] 둘의 사용은 취향의 차이, 회사의 협업자의 컨벤션을 따르는게 좋다고 생각

#### Function 생성자

- 실제로는 거의 사용되지 않는 방식
- 실제로 매겨변수를 전부 문자열로 선언해야함
- 클로저가 생성되지 않음

```js
const sum = new Function("a", "b", "return a+b");
```

### 화살표 함수

- ES6 에서 새롭게 추가
- 타이핑하는 글자수가 줄어드는 효과
- 생성자(this) 사용 불가능 / argumenrs 가 제공되지 않음

```js
const sum = (a, b) => a + b;
```

- 클래스 컴포넌트에서 this 를 사용할 때, 함수 선언문으로 컴포넌트를 만들어서 this.setState 를 사용하려고 하면 this 가 컴포넌트 내부의 this 를 가르키기 때문에 this. setState 사용이 불가능
- 화살표 함수를 사용하면, 만들어 지는 시점에서 자동으로 상위 스코프의 this 를 받아오므로, 클래스 컴포넌트의 this 를 받아서 this.setState 사용 가능

```jsx
import React, { Component } from "react";

export default class Chapter01_1 extends Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 1,
    };
  }

  functionCountUp() {
    // functionCountUp 함수의 this 를 가르킴
    console.log(this);
    this.setState((prev) => ({ counter: prev.counter + 1 }));
  }

  arrowFunctionCountUp = () => {
    // 삼위 클래스 컴포넌트의 this 를 가르킴
    console.log(this);
    this.setState((prev) => ({ counter: prev.counter + 1 }));
  };

  render() {
    return (
      <div>
        <button onClick={this.functionCountUp}>일반 함수</button>
        <button onClick={this.arrowFunctionCountUp}>화살표 함수</button>
      </div>
    );
  }
}
```

### 1.2.3 다양한 함수 살펴보기

#### 즉시 실행 함수

- IIFE(Immediately Invoked Function Expression)
- 정의되는 즉시 실행되는 함수
- 다시 호출이 불가능하여, 보통 이름을 붙이지 않는다

```js
(function (a, b) {
  return a + b;
})(10, 24);

((a, b) => a + b)(10, 24);
```

#### 고차 함수

- 함수를 인수로 받거나, 새로운 함수를 반환하는 함수
- 이러한 특징을 활용하여 다른 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수 작성 가능
- 컴포넌트 내부에서 공통으로 관리되는 로직을 분리하여, 효율적 리팩토링이 가능

### 1.2.4 함수를 만들 때 주의해야 할 사항

- 부수 효과를 최대한 억제할 것
  - 액션을 제거하고 계산만 남기는 컴포넌트를 작성할 것(?)
- 가능한 함수를 작게 만들 것
- 누구나 이해할 수 있는 이름을 붙여라
  - Teeser 를 사용하면 한글로 네이밍 가능

## 1.3 클래스

### 1.3.1 클래스란 무엇인가?

- JS의 객체를 만들기 위한 일종의 템플릿 개념
- constructor (생성자)
- property (프로퍼티)
- getter / setter
  - 프로퍼티의 값을 지정하거나 받는 메서드, get / set 예약어 사용
- 인스턴스 메서드
  - 클래스 내부에 직접 정의한 메서드
- 정적 메서드
  - 인스턴스 없이 이름으로 호출 가능한 메서드
  - 전역에서 사용하는 유틸 함수를 위해 주로 사용
- 상속
  - 클래스를 기반하여 확장하는 개념

### 1.3.2 클래스와 함수의 관계

- ES6에서 나온 개념
- prototype 을 사용하여 구현하던 것을 객체지향 언어를 사용하는 프로그래머들이 좀 더 쉽게 JS 를 사용할 수 있도록 해주는 Syntactic Sugar 로서 적용
