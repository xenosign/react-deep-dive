# CH1. 리액트 개발을 위해 꼭 알아야할 자바스크립트

## 1.1 자바스크립트의 동등 비교

### 1.1.1 JS의 데이터 타입

- 원시 타입

  - boolean
  - null
    - 명시적으로 비어 있는 값
    - type of 의 결과는 object 가 나온다
  - undefined
    - 선언 되었으나 할당되지 않은 값
  - number
    - 최대 2^53 - 1 까지 표현 가능
  - bigint
    - 2^53 - 1 이상의 수 표현 가능
  - string
  - symbol
    - 중복되지 않는 고유한 값, 함수로만 생성 가능

```js
const key1 = Symbol("key");
const key2 = Symbol("key");

key1 === key2; //false

// 동일한 값을 위해서넌 Symbol.for 사용
```

\*\* [p.26] Symbor 은 언제 쓰일까? 그리고 Symbor.for 로 동일한 값을 사용하면 그냥 일반 값을 쓰는 것과 무슨 차이일까?

- 객체 타입

  - object
  - 참조를 전달하기 때문에 참조 타입(reference type)으로 불리운다

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 차이

  - 원시 타입은 메모리에 값 자체를 저장
  - 객체 타입은 프로퍼티를 수정할 수 있으므로 원시 타입과 다르게 변경 가능한 형태로 저장, 값을 복사 할 때도 참조 값이 복사
  - 단, 객체 내부의 프로퍼티의 값은 원시 형태로 저장

### 1.1.3 자바스크립트의 또다른 비교 공식 Object.is

- ES6(2015)에 도입 된 비교 문법, === 의 한계를 극복하기 위해 도입
- === 와 동일하게 자동 형변환을 하지 않고 비교
- === 가 하지 못하는 비교 가능
- 객체간의 비교는 === 와 동일하게 비교

```js
-0 === +0; // true
Object.is(-0, +0); //false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

\*\* [p.29] 이게 리얼루다가 제정신인 언어냐......

### 1.1.4 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 Object.is 를 사용
- ES6 하위 호환을 위해 별도로 구현한 polyfill(이전 브라우저에서 최신 기능 사용을 위한 코드) 사용

- 리액트에서 아용하는 비교 코드

```ts
// polyfill
function is(x: any, y: any) {
  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
}

// 일반
const objectIs: (x: any, y: any) => boolean =
  typeof Object.is === "function" ? Object.is : is;
```

```js
// polyfill
function is(x, y) {
  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
}

// 일반
const objectIs = typeof Object.is === "function" ? Object.is : is;

const obj1 = {};
const obj2 = {};

const objCopy = obj1;

console.log(is(obj1, obj2)); // false
console.log(is(obj1, objCopy)); // true

console.log(objectIs(obj1, obj2)); // false
console.log(objectIs(obj1, objCopy)); // true
```
