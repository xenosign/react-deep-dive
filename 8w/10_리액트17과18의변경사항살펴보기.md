# 10. 리액트 17과 18의 변경 사항 살펴보기

## 10.1 리액트 17 버전 살펴보기

### 10.1.1 리액트의 점진적인 업그레이드

- 리액트 17버전 부터는 하나의 어플리케이션에 2개 이상의 버전이 존재가 가능하도록 업데이트
- 리액트 17 버전에서 16 버전을 lazy 하게 불러오고, 리액트 16을 위한 별도의 루트 요소를 만들어주면 문제 없이 구동 된다

### 10.1.2 이벤트 위임 방식의 변경

- 기존의 16 버전의 리액트는 이벤트를 document 레벨에서 관리하며 필요한 이벤트를 각각의 컴포넌트에 위임하는 방식으로 작동
- 하지만, 이렇게 할 경우 16과 17 버전이 혼재될 경우 하나의 document 에서 다른 버전의 이벤트 핸들러가 존재하게 되므로 문제가 발생할 가능성이 존재
- 이를 해결하고, 점진적인 업그레이드가 가능하도록 17 버전에서는 이벤트 위임을 document 레벨이 아닌 컴포넌트의 최상위 루트에서 처리 하도록 변경 -> 따라서 16 버전은 16 버전의 컴포넌트 루트에서 이벤트를 위임 / 17 버전은 17 버전의 컴포넌트 루트에서 이벤트를 위임하게 되므로 문제 해결이 가능하다
- 또한, JQeury 등의 타 라이브러리와의 충돌도 예방한다

```tsx
import React, { MouseEvent, useEffect } from "react";
import ReactDOM from "react-dom";
export default function App() {
  useEffect(() => {
    document.addEventListener("click", (e) => {
      console.log("이벤트가 document까지 올라옴");
    });
  }, []);

  function 안녕하세요(e: MouseEvent<HTMLButtonElement>) {
    e.stopPropagation();
    alert("안녕하세요!");
  }

  return <button onClick={안녕하세요}>리액트 버튼</button>;
}

ReactDOM.render(<App />, document.getElementById("root"));
```

- 위의 코드는 리액트 16과 17에서 다르게 동작
- 16 에서는 모든 이벤트가 document 에 달려 있기 때문에 e.stopPropagation() 이 의미가 없으므로, 이벤트가 작동
- 17 에서는 이벤트가 컴포넌트 루트에 달려 있으므로 e.stopPropagation() 가 동작하여, 이벤트가 작동하지 않는다

### 10.1.3 import React from 'react' 가 더 이상 필요 없다 : 새로운 JSX transform

- 17 버전 부터는 바벨과 협력하여 import React from 'react' 없이도 JSX 를 해석이 가능하여 에러가 발생하지 않는다
- 불필요한 import 를 삭제해 번들링 크기를 줄이고, 컴포넌트 작성을 더 간결하게 해준다

### 10.1.4 그 밖의 주요 변경 사항

#### 이벤트 풀링 제거

- 리액트 16버전 까지의 이벤트는 이벤트 풀링이라는 기능을 이용하여, 기본 이벤트를 한번 더 감싸서 처리한다.
- 여러 이벤트가 모두 래핑된 이벤트 풀을 만들어 결과적으로 이벤트를 필요에 따라 재사용이 가능해 보이는 장점이 있지만, 이벤트를 받아오고 이벤트가 종료 되면 이벤트를 초기화 하기 위해 null 로 지정하는 과정에서 에러가 발생한다
- 위의 코드는 handleChange 사용 되고 나서 null 로 초기화가 되는데, 그 후에 e 객체에 접근을 하려고 하기 때문에 에러가 발생
- e.persist() 같은 명령어로 해결을 해줘야 했음

```tsx
export default function App() {
  const [value, setValue] = useState("");
  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    // null 로 초기화를 막아 에러를 해결
    e.persist();
    setValue(() => {
      return e.target.value;
    });
  }
  return <input onChange={handleChange} value={value} />;
}
```

- 17 부터는 이벤트 풀링이 사라져서 문제 해결 + 모든 브라우저의 이벤트 처리 능력이 좋아져서 필요가 없어짐

#### useEffect 클린업 함수의 비동기 실행

- useEffect 의 클린업은 16 까지는 동기적으로 처리, 따라서 클린업 동작 전까지는 다른 작업이 방해되는 문제가 발생
- 17 부터는 화면이 완전히 업데이트 된 이후 비동기적으로 클린업이 실행되어 성능이 향상

#### 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 16 에서는 실수로 컴포넌트가 undefined 를 반환하는 문제를 막기 위해, 에러를 발생
- 대신 forwardRef 나 memo 에서는 에러가 발생하지 않던 문제를 17 부터 픽스

## 10.2 리액트 18 버전 살펴보기

### 10.2.1 새로 추가된 훅 살펴보기

#### useId

- 컴포넌트별로 유니크한 값을 생성하는 훅

```jsx
export function UniqueComponent() {
  return <div>{Math.random()}</div>;
}
```

- 특히 SSR 의 경우, 컴포넌트 렌더링 시의 random 값과 클라이언트가 서버에서 결과물을 받아서 다시 random 을 돌렸을 때(하이드레이션) 값이 다른 문제가 발생.
- 따라서 17 까지는 해당 부분을 처리하기 어려웠다
- 18 에 추가된 useId 를 사용하면 이와 같은 문제를 해결할 수 있다
- useId 로 생성된 값은 서로 다른 인스턴스(선언)에 따라 유니크한 랜덤 값을 만들어 내며, SSR 에서도 동일하게 작동된다

#### useTansition

- UI 변경을 가로막지 않고 상태를 업데이트하는 리액트 훅
- 상태 업데이트를 긴급하지 않은 것으로 간주하여, 무거운 렌더링 작업을 미루어 더 나은 사용자 경험 제공이 가능하다
- useTransition 은 isPending 과 startTranstion 이 담긴 배열을 반환, isPending 은 boolean 값이고 startTranstion 급하지 않은 상태 업데이트 값의 배열

```tsx
import { useState, useTransition } from "react";
// ...

export default function TabContainer() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState<Tab>("about");
  function selectTab(nextTab: Tab) {
    startTransition(() => {
      setTab(nextTab);
    });
  }

  return (
    <>
      {/* ... */}
      {isPending ? (
        "로딩 중"
      ) : (
        <>
          {tab === "about" && <About />}
          {tab === "posts" && <Posts />}
          {tab === "contact" && <Contact />}
        </>
      )}
    </>
  );
}
```

- 위의 코드에서 `<About />`, `<Posts />`, `<Contact />` 등이 로딩이 오래 걸리는 컴포넌트였다면 tab 상태 값에 따라 서로 다른 탭을 불러올 때, 기존 탭의 렌더링이 완료되기 전 까지는 새로운 탭의 랜더링이 동기적으로 처리되어 느린 문제점이 발생
- 하지만 위와 같이 useTransition 을 사용하면, 탭이 변경되면 기존 랜더링을 후순위로 미루고 지금 필요한 컴포넌트 랜더링을 시작하므로 문제를 해결할 수 있다
- 단, useTransition 는 상태 업데이트에만 사용이 가능하며 값에 대해서 사용하고 싶으면 useDefferdValue 를 사용
- startTranstion 내부는 상태 업데이트 함수만 넘길 수 있다. 그리고 또한 동기 함수만 넘겨야 한다.
- setTimeOut 같은 비동기 함수를 넘기면 정상적으로 작동하지 않는다

#### useDefferedValue

- 리랜더링이 급하지 않는 부분을 지연시키는 훅이며, 특정시간 동안 발생하는 이벤트를 하나로 인식해 한 번만 실행하게 해주는 디바운스와 비슷하나 장점이 몇가지 존재
- useTransition 과는 달리 함수를 넘기는 것이 아니라 값으로만 처리가 가능하다. 상황에 맞는 것을 사용하면 된다

```tsx
export default function Input() {
  const [text, setText] = useState("");
  const deferredText = useDeferredValue(text);

  const list = useMemo(() => {
    const arr = Array.from({ length: deferredText.length }).map(
      (_) => deferredText
    );

    return (
      <ul>
        {arr.map((str, index) => (
          <li key={index}>{str}</li>
        ))}
      </ul>
    );
  }, [deferredText]);

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setText(e.target.value);
  }

  return (
    <>
      <input value={text} onChange={handleChange} />
      {list}
    </>
  );
}
```

- text 는 바로바로 state 로서 업데이트 하지만, 시간이 걸리는 list 는 업데이트 기준을 defferdText 로 설정하여 후순위로 렌더링하여 더 나은 사용자 경험 제공

#### useSyncExternalStore

-
