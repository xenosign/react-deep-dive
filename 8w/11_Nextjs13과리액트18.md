# 11. Next.js 13 과 리액트 18

## 11.1 app 디랙터리의 등장

- next 는 모든 페이지가 폴더와 파일로 구분되어 있어 레이아웃 적용 부분에서 문제가 있었다
- 페이지 공통으로 무언가를 집어 넣을 수 있는 곳은 \_document 와 \_app 이 유일

### 11.1.1 라우팅

- next 12 이하 버전에서는 /pages/a/b.tsx 와 /pages/a/b/index.tsx 가 동일한 주소로 변환
- next 13 에서는 /app/a/b 로 폴더명 까지만 주소로 변환되며, 파일명은 무시

#### layout.js

- 페이지의 전체적인 레이아웃을 구성하는 요소로 폴더에 해당 파일이 존재하면, 하위 폴더 및 주소에 모두 영향을 준다
- 해당 내용 적용으로 주소별 공통 UI 뿐 아니라, 웹페이지에 필요한 공통 코드도 삽입할 수 있다

#### page.js

- 기존 next 의 페이지 개념을 담당

#### error.js

- 라우팅 영역에서 사용하는 공통 에러 컴포넌트로, 해당 파일을 사용하면 라우팅 별로 서로 다른 에러를 발생 시킬 수 있다

#### not-found.js

- 404 페이지 전용 파일

#### loading.js

- Suspense 를 기반으로 로딩 중에 보여줄 파일

#### route.js

## 11.2 리액트 서버 컴포넌트

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 기존 SSR 의 방식, 서버에서 DOM 을 불러오고 클라이언트는 만들어진 DOM 을 기준으로 하이드레이션을 진행하여 이벤트 핸들러를 DOM 에 추가하고 요청에 따라 응답하는 방식은 한계점을 지닌다
- 자바스크립트 번들크기가 0인 컴포넌트 생성이 불가능. 타 라이브러리 사용시 서버와 클라이언트 모두 해당 라이브러리를 로딩해야 하는 단점이 발생
- 백엔드 리소스에 직접적 접근이 불가능
- 자동 코드 분할이 불가능. 코드를 여러 단위로 나누어 필요할 때만 동적으로 로딩하는 기능을 리액트에서는 lazy 로 구현이 가능하지만 SSR 에서는 항상 lazy 로 감싸줘야만 하며 동적 판단에 따라 어떤 컴포넌트를 미리 그릴지 판단이 어렵다
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
- 추상화에 드는 비용이 증가. 템플릿 언어에 비해 다양한 언어적 기능을 제공하지만 이에 따른 비용이 증가

### 11.2.2 서버 컴포넌트란?

- 서버에서 구동이 가능한 컴포넌트를 말한다. 서버에서 만들어서 빠르게 HTML 을 내려주는 SSR 과는 다른 개념이다

- 서버 컴포넌트 문제점

  - 요청되면 딱 한번 생성되어 전달 되므로 상태 및 생명주기 활용이 불가능
  - 브라우저에서 사용되는 DOM API, window, document 등에 접근이 불가능

- 클라이언트 컴포넌트 문제점

  - 서버 컴포넌트를 불러올 수 없다

- 공용 컴포넌트

  - 위에 기술한 컴포넌트의 문제점을 동시에 가지는 컴포넌트

- 리액트는 기본적으로 모든 컴포넌트를 공용 컴포넌트로 판단하며 "use client" 라고 작성한 컴포넌트만 클라이언트 컴포넌트로 판단
- 클라이언트 컴포넌트에서 서버 컴포넌트를 import 하면 에러 발생

\*\* [p. 736] 너네 이거 알지? 하면서 부수적인 것만 설명 하는데... 흐름이 너무 구립니다. 리액트 내용 쭉하고 넥스트 같이 나왔으면 이해가 훨 잘되었을거 같은데, 리액트 하다 넥스트하다 리액트 하다 넥스트하다 하다보니 흐름이 영...

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

- 서버에서 스트리밍 형태로 페이지 정보를 보낸다. 따라서, 클라이언트는 줄 단위로 JSON 을 읽어서 컴포넌트 렌더링이 가능하여 되도록 빠르게 사용자에게 결과물을 보여줄 수 있다
- 컴포넌트 별로 번들링이 가능하여, 필요에 따라 특정 컴포넌트를 지연하여 받는 등의 처리가 가능하다
- JSON 으로 직렬화 된 데이터를 받아 빠르게 컴포넌트 트리의 구성을 한다. 즉, SSR 이 단순히 HTML 을 그리는 것에 비해 더 고도화된 작업을 빠르게 수행할 수 있다
- 이 모든 내용은 SSR 의 단점을 극복하기 위해서 적용 된 내용이다

### 11.3 Next.js 에서의 리액트 서버 컴포넌트

- 13 버전에 들어서 서버 컴포넌트 기능이 적용 되었다
- page.js 와 layout.js 는 반드시 서버 컴포넌트로 적용되기 때문에 제약 사항을 반드시 따라야 한다
- 서버 컴포넌트는 클라이언트 컴포넌트를 children props 로 받는 것만 가능한데, page.js 와 layout.js 는 DOM 트리의 최상단에 위치하므로 서버 컴포넌트의 장점만 가질 수 있다.
- 이를 이용하여 page.js 와 layout.js 는 클라이언트에 부담을 주지 않고 서버에서 빠르게 생성이 가능하며 직렬화된 JSON 을 통해 클라이언트에 전달 되므로 빠르게 최초 페이지와 레이아웃을 사용자에게 제공이 가능해진다
- 이렇게 그려진 페이지와 레이아웃에 클라이언트에서 그린 클라이언트 컴포넌트가 얹어지는 개념이므로, 모든 작업을 클라이언트에서 수행하던 것에 비해 효율성과 사용성 제공이 가능해 진다

\*\* [p. 741] 이런건 설명을 해야하지 않겠니?

### 11.3.1 새로운 fetch 동비과 getServerSideProps, getStaticProps, getInitialProps 의 삭제

- 서버 컴포넌트의 도입으로 SSR 에 서만 필요한 특수한 기능이 삭제 되었다
- 최근 유행인 SWR 와 React-Query 처럼 특정 fetch 요청을 렌더링이 끝날 때까지 캐싱을 하여 중복된 요청을 방지하는 역할을 한다

### 11.3.2 정적 렌더링과 동적 렌더링

- Next 13 버전에서는 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 미리 렌더링을 생성하여 캐싱해서 제공하는 기능 추가
- cache 옵션으로 설정이 가능

```tsx
async function fetchData() {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts`,
    // no-cache 옵션을 추가했다.
    { cache: "no-cache" }
    // Next.js에서 제공하는 옵션을 사용해도 동일하다.
    { next: { revalidate: 0 }}
  );
  const data = await res.json();
  return data;
}

export default async function Page() {
  const data: Array<any> = await fetchData();
  return (
    <ul>
      {data.map((item, key) => (
        <li key={key}>{item.id}</li>
      ))}
    </ul>
  );
}
```

- 특정 주소에 대한 캐싱의 경우는 generateStaticParams 를 사용하면 된다

### 11.3.3 캐시와 mutationg, 그리고 revalidating

- `{ next: { revalidate: 0 }}` 와 같은 옵션을 사용해서 시간을 정해두고 해당 시간이 지나면 데이터를 불러와서 페이지를 렌더링 하는 것이 가능
