# 03. 리액트 훅 깊게 살펴보기

## 3.1 리액트의 모든 훅 파헤치기

### 3.1.1 useState

- 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅

#### useState 구현 살펴보기

- state 초깃값을 넘겨 주지 않으면 undefined 로 설정

\*\* [p. 194] \_\_SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED 변수명 잼나네요 ㅋㅋ

#### 게으른 초기화(Lazy initializtion)

- useState 에 변수 대신 함수를 넘기는 것
- 공식문서에는 useState 의 초깃값이 복잡하거나 무거운 연산 포함시에 사용을 권고
- 리렌더링이 발생하면 함수의 실행은 무시

```jsx
// 일반적 사용
const [count, setCount] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
);

// 게으른 초기화
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

- 예제 코드

```jsx
function App() {
  const [state, setState] = useState(() => {
    // 최초 설정 시, 1번만 실행 된다
    console.log("복잡한 연산");
    return 0;
  });

  return (
    <>
      <h1>{state}</h1>
      <button onClick={() => setState((prev) => prev + 1)}>리렌더링</button>
    </>
  );
}
```

- 최초 실행시 한번만 실행이 되고, 리렌더링 시 다시 실행이 안되므로 낭비 없이 효율적으로 사용이 가능하다
- localStorage / sessionStorage 접근 이나 배열 함수에 대한 접근, 초깃값 계산이 복잡한 경우 사용하면 좋다

### 3.1.2 useEffect

- 컴포넌트의 내부 값을 활용하여 동기적으로 부수 효과를 만드는 매커니즘을 제공하는 훅

#### useEffect 란?

- 특별한 기능을 사용하는 것이 아니라, 의존성에 있는 값을 보면서 의존성의 값이 이전과 하나라도 다른게 있으면 부수 효과를 실행하는 평범한 함수
- state 와 props 의 변화로 발생하는 렌더링 과정에서 실행되는 부수 효과 함수

#### 클린업 함수의 목적

- 이벤트를 등록하고 지울 때 사용해야 한다?

```jsx
function App() {
  const [counter, setCounter] = useState(0);

  useEffect(() => {
    const addMouseEvent = () => {
      console.log(counter);
    };

    window.addEventListener("click", addMouseEvent);

    return () => {
      console.log("클린업 함수 실행!", counter);
      window.removeEventListener("click", addMouseEvent);
    };
  }, [counter]);

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={() => setCounter((prev) => prev + 1)}>리렌더링</button>
    </>
  );
}
```

```jsx
// 실행 결과

// 클린업 함수 실행! 0
// 1

// 클린업 함수 실행! 1
// 2
```

- 클린업 함수는 이전의 counter 를 참조해서 실행이 된다
- 새로운 값과 함께 렌더링 된 후, 다음 렌더링이 시작되기 전에 실행된다. 그리고 이 때에 참조하는 값은 이전 렌더링의 값이다
- 따라서, 클린업을 제대로 설정하지 않을 경우 특정 이벤트 핸들러가 무한히 추가되는 문제가 발생 가능
- 클래스형 컴포넌트의 생명주기 메서드는 컴포넌트가 DOM 에서 사라질 때를 기준으로 하지만, useEffect 는 말그대로 이전 상태를 청소해 주는 개념으로 작동한다

#### 의존성 배열

- 빈 배열 -> 최초 마운트 시 한번만 실행
- 빈 값 -> 렌더링 시 마다 실행
- 빈 값을 의존성 배열로 가지는 useEffect 는 컴포넌트가 랜더링 된 이후에 실행 된다. 렌더링 시에 실행되는 내부 함수와는 다른 특성을 가진다

#### useEffect 를 사용할 때, 주의할 점

##### eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 피하라

- 즉, 빈배열을 의존성 배열로 가지는 useEffect 사용은 최대한 자제할 것
- 클래스형 컴포넌트의 componentDidMount 의 개념으로 사용하는데 이렇게 될 경우 버그의 가능성을 가진다

```jsx
function Component(log) {
  useEffect(() => {
    logging(log);
  }, []);
}
```

- 해당 코드는 해당 log 가 넘어와 최초로 렌더링 된 시점에 한번만 실행된다
- 하지만 log 가 아무리 변하여도 log 를 기록하는 부수효과는 실행이 안되는 구조를 가지기 때문에 props 의 흐름을 해치게 된다
- 위와 같은 코드는 해당 컴포넌트를 호출하는 부모 컴포넌트에서 해당 log 가 발생하는 시점에서 logging 함수를 실행하는 방법으로 처리하는 것이 더 좋은 방법이다

##### useEffect 의 첫번째 인수에 함수명을 부여하라

- 함수명을 부여하여 useEffect 의 부수효과를 단번에 알 수 있도록 하는 것은 가독성에 도움이 된다

```jsx
// 함수명을 안 붙인 경우
useEffect(() => {
  logging(user.id);
}, [user.id]);

// 함수명을 붙인 경우
useEffect(
  logActiveUser() => {
    logging(user.id);
  },
  [user.id]
);
```

##### 거대한 useEffect 를 만들지 마라

- useEffect 는 의존성 배열을 바탕으로 렌더링 시 부수효과를 실행하므로 부수효과가 커질 수록 성능에 악영향을 미친다
- useEffect 가 거대해야 한다면, 최대한 적은 의존성 배열을 사용하는 여러개의 useEffect 로 분리하는게 좋다
- 위의 상황이 불가피하면 useCallback, useMemo 로 정제한 내용만 useEffect 에 들어가도록 하여 성능 이슈를 줄이고, 언제 useEffect 가 싱행되는지 명확하게 알 수 있다

##### 불필요한 외부 함수를 만들지 마라

```tsx
function Component({ id }: { id: string }) {
  const [info, setInfo] = useState<number | null>(null);
  const contollerRef = useRef<AbortController | null>(null);
  const fetchInformation = useCallback(async (fetchId: string) => {
    controllerRef.current?.abort();
    controllerRef.current = new AbortController();

    const result = await fetchInfo(fetchId, { signal: controllerRef.signal });
    setInfo(await result.json());
  }, []);

  useEffect(() => {
    fetchInformation(id);
    return () => controllerRef.current?.abort();
  }, [id, fetchInformation]);

  return <div>{/* 렌더링 */}</div>;
}
```

- 위의 코드는 props 를 받아서 해당 정보를 바탕으로 API 를 호출하는 useEffect 를 가지는데, useEffect 밖에서 함수를 선언하다보니 불필요한 코드가 많아지고 가독성이 떨어진다

```tsx
// 수정버전
function Component({ id }: { id: string }) {
  const [info, setInfo] = useState<number | null>(null);

  useEffect(() => {
    const controller = new AbortController();

  (async () => {
    const result = await fetchInfo(id. {signal: controller.signal});
    setInfo(await result.json());
  })();

  return () => controller.abort();
  }, [id]);

  return <div>{/* 렌더링 */}</div>;
}
```

- 위와 같이 수정 시, 코드도 간결해지고 의존성 배열도 줄어들며 무한 루프를 막기 위해 넣었던 코드인 useCallback 도 삭제 가능

##### 왜? useEffect 의 콜백 인수로 비동기 함수를 바로 넣을 수 없을까?

- useEffect 의 콜백 인수로 미동기 함수로 넣을 경우 useEffect 의 경쟁 상태(race condition)를 유발 가능
- 응답 시간에 따라 이전 state 의 값을 기반으로 결과가 나올 수 있다
- useEffect 인수로 비동기 함수를 지정할 수 없을 뿐, 실행은 문제가 없으므로 내부에서 선언해서 실행하는 방법으로 해결 가능

```jsx
useEffect(() => {
  let shouldIgnore = false;

  const fetchData = async () => {
    const response = await fetch("http://");
    const result = await response.json();

    if (!shouldIgnore) setDate(result);
  };

  fetchData();

  // useFFect 실행 시 마다 함수 생성 및 실행이 반복 되므로, 클린업을 이용하여 비동기 함수에 대한 처리를 하는 것이 좋다
  // AbortController 를 통해 직전 요청 자체를 취소하는 방법도 있다
  return () => (shouldIgnore = true);
}, []);
```

\*\* [p. 208] 이거 왜 어떨 땐, JS 어떨 땐 TS 번갈아 쓰는 걸까요? ㅋㅋㅋㅋ
