# 09. 모던 리액트 개발 도구로 개발 및 배포 환경 구축하기

## 9.1 Next.js 로 리액트 개발 환경 구축하기

### 9.1.1 crate-next-app 없이 하나씩 구축하기

```bash
npm i react react-dom next

npm i @types/node @types/react @types/react-dom eslint eslint-config-next typescript --save-dev
```

### 9.1.2 tsconfig.json 작성하기

- TS 설정은 tsconfig.json
- JSON 최상단에 $schme 와 같은 키를 넣어서, schemaStore 로 부터 정보를 받아와 JSON 파일이 무엇을 의미하는지 어떤 키와 값이 있는지를 알려주는 도구. 해당 값을 설정하면 IDE 에서 자동 완성이 가능해 진다

```json
{
  "$schema": "https://json.schemastore.org/tsconfig.json",
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": "src",
    "paths": {
      "#pages/*": ["pages/*"],
      "#hooks/*": ["hooks/*"],
      "#types/*": ["types/*"],
      "#components/*": ["components/*"],
      "#utils/*": ["utils/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

#### compilerOptions

- TS 를 JS 로 컴파일 할 때 사용하는 옵션
- target : TS 가 변환하는 JS 의 버전, 문법이 지원하지 않는 폴리필 까지 지원은 X
- lib : lib 컴파일 된 언어에서 사용할 라이브러리에 대한 정보. 위의 Config 에는 esnext, dom 등이 추가 되어 Promise, Map 같은 ES6 의 문법도 라이브러리를 통해 사용이 가능하다
- allowJS : JS 파일도 같이 컴파일 할지 여부. js 와 ts 가 혼재된 경우 사용
- skipLibCheck : d.ts 검사를 skip 할지 정하는 옵션
  - d.ts : TS 에서 제공하는 타입에 대한 정보를 담고 있는 파일. TS + React 를 사용하면 JS 의 타입 만으로는 타입 매칭이 불가능 하므로 d.ts 에서 도움을 받아야 한다
- strict : 엄격 모드 여부

  - alwaysStrict : 모든 JS 파일에 use strict 추가
  - strictNullChecks : 엄격한 null check 활성화 여부
  - strictBindCallApply : 엄격한 인수 체크 활성화 여부 (인수가 2개인데 3개 넘겨줄 경우 JS 는 넘기지만, 해당 옵션이 켜지면 에러 발생)
  - strictFunctionTypes : 함수 타입 엄격 체크 여부 (함수 타입 체크에 예외가 없는 검사 실행)
  - strictPropertyInitializtion : 클래스 내부의 프로퍼티에 값 할 당시 타입 엄격 체크
  - noImplicitAny : 타입 명시가 안된 변수에 자동으로 any 를 부여하는 기능 끄기
  - noImplicitThis : this 를 추론할 수 없는 상황에서 자동으로 any 를 부여하는 기능 끄기
  - noUnknownInCatchVariables : catch 구문에서 잡는 변수에 기본으로 any 를 할당하는데 4.0 버전 부터느느 unknown 을 할당하는 옵션. catch 구문에서 잡히는 것이 반드시 에러가 아닐 수 있으므로 에러는 if 문을 사용하여 가드하는 것이 바람직 하다

  ```js
  try {
    throw 5;
  } catch (e) {
    if (e instanceof Error) console.log(e);
  }
  ```

  - forceConsistentInFileName : 파일 이름의 대소문자 구분 강제 옵션
  - noEmit : 컴파일 없이 타입 체크만 하는 옵션. next 에서는 swc 가 컴파일을 하므로 굳이 ts 를 js 로 컴파일 한 후 다시 swc 로 컴파일할 이유가 없으므로 사용한다
  - esModuleInterop : CommonJS 방식으로 모낸 보듈을 ES 모듈(import) 로 가져올 수 있게 하는 옵션 (ES5, ES6 를 동시에 사용하는 프로젝트일 경우 사용)
  - module : 모듈 시스템(CommonJS or Esnext) 설정. 즉, require 냐 import 냐
  - moduleResolution : 모듈 해석 방식 설정.
    - node : node_moudules 에서 기본으로 모듈 해석. 단, CommonJS 의 경우에만 사용 가능
    - classic : tsconifg.json 에 설정 된 디렉터리를 기준으로 해석
  - resolveJsonModule : JSON 파일 import 여부 설정 -> true 면 자동으로 allowJs 옵션이 켜진다
    - \*\* [p.537] 왜? 생각해 보자
  - isolatedMoudles : TS 컴파일러는 파일에 import, export 가 없으면 단순 스크립트 파일로 인식해 이러한(?) 파일이 생성 되지 않도록 막는다. 즉, 모듈과 연계가 안된 단독 파일 생성을 막기 위한 옵션
    - \*\* [p.537] 왜 막지? 생각해 보자
  - jsx : .tsx 파일 내부의 jsx 를 어떤 방식으로 컴파일 할지 설정
    - react : 기본값, React.createElement 로 변환
    - react-jsx : 리액트 17에서 등장, react/jsx-runtime 을 사용하여 변환. React.creatElement 를 사용하지 않아서 import React from 'react' 가 필요 없다
    - react-jsxdev : react-jsx 와 동일하나 디버깅 정보 추가
    - preseve : 변환 하지 않고 유지. next 는 jsx 역시 swc 가 변환해주므로 이 옵션을 사용한다
    - react-native : 리액트 네이티브에서 사용, 실제로 변환을 안한다
  - incremental : TS 가 마지막 컴파일 정보를 .tsbuildinfo 파일로 만들어 디스크에 저장. 해당 컴파일 정보를 비교하여 컴파일 비용이 제일 적은 컴파일 옵션을 찾아서 사용이 가능해 진다
  - baseUrl : 모듈을 찾을 때, 기준이 되는 디렉토리 설정
  - paths : 상대 경로(../, ../../)가 중첩되어 가독성이 떨어지는 상황에서, 해당 옵션을 사용하면 경로에 별칭(alias)를 설정 할 수 있게 해주는 옵션. $, # 등을 사용하여 설정한다. 단, @ 는 angular, @types 와 같은 스코프 패키지와 충돌 가능성이 있으므로 피하는 것이 좋다
  - include : TS 컴파일 대상에 포함 시킬 파일 목록, 위에서는 ts 파일과 next 에서 자동으로 생성하는 타입 파일인 next-env.d.ts 를 포함
  - exclude : TS 컴파일 대상에 제외 시킬 파일 목록

- 나머지 옵션들은 http://www.typescriptlang.org/tsconfig 에서 확인 가능

### 9.1.3 next.config.js 작성하기

- Next.js 설정을 위한 파일

```js
/** @type {import('next').NextConfig} */ const nextConfig = {
  reactStrictMode: true,
  poweredByHeader: false,
  eslint: { ignoreDuringBuilds: true },
};
module.exports = nextConfig;
```

- reactStrictMode : 엄격 모드 활성화
- poweredByHeader : 보안 취약점인 X-Powered-By 해더 삭제
- eslint: { ignoreDuringBuilds: true } : 빌드 시에 ESLint 무시, Next.js 빌드에서 ESLint 를 수행하므로 효율 증대

### 9.1.4 ESLint 와 Prettier 설정하기

- ESLint 를 설치만 하면 코드에 있을 잠재적 문제만을 확인할 뿐, 코드 스타일링 정의는 안해주기 때문
- 해당 과정에서는 @titicaca/eslint-config-triple 을 사용
  - https://github.com/titicacadev/eslint-config-triple#eslint-config-triple

```bash
npm i -D @titicaca/eslint-config-triple
```

- eslint-config-next 와 eslint-config-triple 이 함께 작동하기 위해서는 아래와 같은 별도의 설정 필요

```js
const path = require("path");

const createConfig = require("@titicaca/eslint-config-triple/create-config");

const { extends: extendConfigs, overrides } = createConfig({
  type: "frontend",
  project: path.resolve(__dirname, "./tsconfig.json"),
});

module.exports = {
  extends: [...extendConfigs, "next/core-web-vitals"],
  overrides,
};
```

- extends 에 next/core-web-vitals 를 추가하여 두 가지 설정을 전부 적용
- 이 외에 .eslintignore, .pritterignore 에 .next 나 node_modules 를 추가하여 직접 짠 코드가 아닌 코드는 분석에서 제외

### 9.1.5 스타일 설정하기

- Next.js 에 styled-components 를 적용

```bash
npm i styeld-components
```

- swc 에 styled-components 를 사용하는 것을 알리기 위해 next.config.js 에 내용 추가 -> swc 가 더 빠르게 컴파일이 가능

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  poweredByHeader: false,
  eslint: { ignoreDuringBuilds: true },
  // styeld-components 내용 추가
  styeldComponents: true,
};

module.exports = nextConfig;
```

- next 폴더의 pages/\_document.tsx Head 에 ServerStyleSheet 추가

### 9.1.6 어플리케이션 코드 작성

- Next 를 위한 명령어를 package.json 에 추가

```json
{
  "scripts": {
    "dev": "next dev",
    "start": "next start",
    "build": "next build",
    "lint:es": "eslint '**/*.{js,ts,tsx}'",
    "lint:es:fix": "npm run lint:es -- --fix",
    "prettier": "prettier '**/*' --check",
    "prettier:fix": "prettier '**/*' --write"
  }
}
```

### 9.1.7 정리

- 이러한 세팅은 시간이 걸리므로 협업시에는 보일러 플레이트 프로젝트를 만들고, 깃허브에서 'Template repository' 옵션을 체크해서 사용하는 방법을 추천

## 9.2 깃허브 100% 활용하기

### 9.2.1 깃허브 액션으로 CI(Continuous Intergration) 환경 구축하기

- CI : 소프트웨어 코드를 지속적으로 개선하면서 빌드하고 테스트해 코드의 정합성을 확인하는 과정
- 기존에는 Jenkins 가 자주 사용 되었다
  - 단, 설치형이고 서버를 구축해야하므로 설치 및 유지 보수 측면에서 번거로움이 발생
- 최근에는 깃허브 액션을 사용
  - 원래는 CI 툴이 아니지만 깃허브에서 발생하는 다양한 이벤트를 트리거 삼아 다양한 액션을 수행하는 기능

#### 깃허브 액션의 기본 개념

- 러너(runner) : 파일로 작성된 깃허브 액션이 실행되는 서버, 특별히 지정하지 않으면 깃허브 공용 서버를 사용하며 별도의 서버를 구축하여 사용이 가능하다
- 액션 : yaml 파일로 구성 된 러너에서 실행되는 하나의 작업 단위
- 이벤트 : 깃허브 액션의 트리거가 되는 이벤트
  - pull_request
  - issues
  - push
  - schedule : 이벤트와는 별개로 특정 시간에 작동
  - step : 직렬로 실행되는 작은 작업 단위
  - job : step 의 집합

#### 깃허브 액션 작성하기

- 액션을 작성하려면 저장소의 루트 폴더에 .github/workflows 폴더를 생성하고 내무에 yaml 파일 작성을 하면 된다

```yaml
name: chapter7 build
run-name: ${{ github. actor }} has been added new commit.

on:
  push:
    branches-ignore:
      - "main"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16
      - name: "install dependencies"
        working-directory: ./chapter7/my-app
        run: npm ci
      - name: "build"
        working-directory: ./chapter7/my-app
        run: npm run build
```
