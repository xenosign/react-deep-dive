# CH2. 리액트의 핵심 요소 깊게 살펴보기

## 2.1 JSX 란?

- 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는데 도움을 주는 문법
- 그대로 사용하면 에러 발생, 사용을 위해서는 순수 JS 로의 트랜스파일이 필요하다(by Babel)

### 2.1.1 JSX 의 정의

- JSXElement, JSXAttributes, JSXChildren, JSXStrings 라는 4가지 컴포넌트로 구성

\*\* [p. 117] 이거 Element 만 왜 단수죠?

#### JSXElement

- JSXOpeningElement : HTML 요소를 여는 요소
- JSXClosingElement : JSXOpeningElement 를 닫는 요소, 반드시 쌍으로 존재 해야함
- JSXSelfClosingElement : 스스로 종료되는 요소의 형태, <input /> 같은 형태
- JSXFragment : 아무런 요소가 없는, 특정 요소들을 감싸는 의미적 요소. < /> 는 존재 불가능 <></> 처럼 쌍으로만 사용 가능

- 요소명은 대문자? : HTML 태그와 구분하기 위해서, 대문자로 시작한다

##### JSXElementName

- JSX 에 이름을 붙일 수 있는 규칙, JS 의 식별자 규칙을 다룬다
- : 를 통해 다른 식별자를 이어주는 것 가능, 단 한번만 가능
  - 가능 : <foo:bar />
  - 불가능 : <foo:bar:baz /> 는 불가능
- . 를 통해 다른 식별자 이어주는 것 가능, 여러번 이어서 사용 가능 단 : 와 혼용은 불가능
  - 가능 : <foo.bar /> <foo.bar.baz />
  - 불가능 : <foo:bar.baz />

##### JSXAttributes

- JSXElement 에 부여할 수 있는 속성을 의미한다, 속성 값이므로 필수 X
- 기본적으로 전개 연산자를 사용하여 JS 에 취급되는 모든 표현식(조건문, 화살표 함수, 할당식)을 전달 가능
- 속성을 키와 값을 짝지어 전달, JSXElementName 과 마찬가지로 : 를 이용하여 키를 사용 가능
  - . 는 왜 안되나요? 아마도 객체등도 전달이 가능한 구조를 가지기에 문법적으로 오류를 일을킬 가능성을 배제하는 것으로 보임
- 할당되는 값은 문자열, 객체, 다른 JSXElement, JSXFragment 등이 전달 가능하다

\*\* [p. 120] 네임스페이스에서 : 는 되는데 . 는 왜 안될까요?
\*\* 아래의 babel 변환 코드 보고 테스트 해볼것

##### JSXChildren

- JSXElement 의 자식 값, 트리 구조를 나타내는 문법이므로 부모 자식을 표현 가능
- JSXChildren 은 JSXChild 를 0개 이상 가질 수 있다(= 없어도 무방하다)
- 문자열을 가질 수 있다. 단, '{', '<', '>', '}' 는 JSX 문법과 혼동이 가능하므로 다르게 전달해야 한다
- 다른 JSX 요소 전달 가능
- JSXFragment 전달 가능

##### JSXStrings

- HTML 에서 사용 가능한 문자열은 전부 사용 가능
- 단, '\' 의 경우 JS 의 특수 문자를 처리하는데 사용하므로 '\' 를 쓰고 싶으면 '\\' 로 써야 함

### 2.1.2 JSX 예제

- 위의 규칙을 만족하면 전부 사용이 가능하다

```jsx
// 사용되는 경우는 없지만 유효한 문법들
cosnt ComponentA = () => {
  return <A.B></A.B>;
}

const ComponentB = () => {
  return <A.B.C></A.B.C>;
}

const ComponentC = () => {
  return <A.B:C></A.B:C>;
}

const ComponentD = () => {
  return <$></$>;
}

const ComponentE = () => {
  return <_></_>;
}
```

### 2.1.3 JSX 는 어떻게 자바스크립트로 변환될까?

- @babel/plugin-transform-react-jsx 플러그인을 사용하여 JSX 를 JS 로 변환

- 변환하기 전 JSX 코드

```jsx
const ComponentA = <A required={true}>Hello World</A>;

const ComponentB = <>Hello World</>;

const ComponentC = {
  <div>
    <span>hello world</span>
  </div>
}
```

- 변환 후 js 코드

```js
"use strict";

var ComponentA = React.createElement(
  A,
  {
    require: true,
  },
  "Hello World"
);

const ComponentB = React.createElement(React.Fragment, null, "Hello, world");

const ComponentC = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello, world")
);
```

#### 직접 해보기

- @babel/standalone 모듈을 사용하여 직접 변환이 가능

```js
import * as Babel from "@babel/standalone";

Babel.registerPlugin(
  "@babel/plugin-transform-react-jsx",
  require("@babel/plugin-transform-react-jsx")
);

const BABEL_CONFIG = {
  presets: [],
  plugins: [
    [
      "@babel/plugin-transform-react-jsx",
      {
        throwIfNamespace: false,
        runtime: "automatic",
        importSource: "custom-jsx-library",
      },
    ],
  ],
};

const SOURCE_CODE = `const ComponentA = <A>안녕하세요.</A>`; // code 변수에 트랜스파일된 결과가 담긴다.

const { code } = Babel.transform(SOURCE_CODE, BABEL_CONFIG);
```

- 이렇게 코드가 변환되는 결과를 알게 된다면 더 효율적인 방법으로 코드 리팩토링이 가능하다
- JSX 반환 값이 결국 React.createElement 로 귀결되므로 코드의 중복 부분을 좀 더 생략이 가능

```js
// ❌ props 여부에 따라 children 만 달라지는 경우
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// ⭕ JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
import { createElement } from "react";
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? "h1" : "span",
    { className: "text" },
    children
  );
}
```

### 2.1.4 정리

- JSXNamespaceName, JSXMemberExpression 은 사용하지 않는다
- 다른 언어도 JSX 를 채용하여 사용 중
- 단, 잘못쓰면 오히려 코드 가독성을 해치니 주의해서 사용해야 함
- JSX 가 어찌 변환되는지를 알고 더 효율적으로 사용하는 것도 중요

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM 과 브라우저 렌더링 과정

1. 브라우저가 HTML 파일 다운로드
2. HTML 을 파싱하여 DOM 노드 트리를 구성
3. 2번 과정에서 CSS 도 같이 다운로드
4. CSS 도 파싱하여 CSS 트리(CSSOM) 구성
5. 2에서 작성한 DOM 을 보이는 것만 순회 (= 효율성을 위해서)
6. 보이는 DOM 요소에 대한 CSSOM 정보를 찾아서 적용

- 레이아웃 : 각 DOM 노드가 브라우저 화면 어디에 나타나야 하는지 계산하는 과정
- 페인팅 : 레이아웃에 실제 유효한 모습을 그리는 과정

### 2.2.2 가상 DOM 의 탄생 배경

- 페이지 인터랙션의 증가와 SPA(= Single Page Application) 의 증가로 기존 렌더링 과정에 대한 한계 발생
  - 변화가 없는 요소를 레이아웃, 페인팅을 반복하는 비효율
  - 전체 페이지의 렌더링으로 깜박이는 현상 발생
- 이를 해결하기 위해 페이지에서 표시해야할 DOM 을 메모리에 저장하고, 변경에 대한 준비가 완료 되면 실제 DOM 에 반영하는 가상 DOM 을 통해 해결
  - 렌더링 과정을 최소화 가능
  - 일반 DOM 처리보다 더 빠르다는 것은 잘못된 사실이다 -> 페이지를 만들기에 부족함이 없을 정도로 충분히 빠르다가 맞는 이야기

### 2.2.3 가상 DOM 을 위한 이키텍쳐, 리액트 파이버

- 렌더링 과정 최적화를 가능하게 해주는 아키텍쳐

#### 리액트 파이버란?

- 재조정(Reconciliation) 을 관리하는 객체
- 재조정(Reconciliation) : 메모리의 가상 DOM 과 실제 DOM 을 비교하여, 둘 사이의 차이가 있으면 화면에 렌더링을 요청
- 모든 작업은 비동기로 발생
  - 과거에는 스택으로 구성되어, JS 의 싱글 스레드 특징과 맞물려 동기적으로 작동, 도중에 다른 작업 및 중단이 불가능한 문제 발생
- 자세한건 2.4 장에서
- state 가 변경되거나, 생명 주기 메서드 실행, DOM 변경이 필요한 시점에 리액트 파이버가 실행된다
- 리액트 파이버의 구성 요소를 사용하여 작업을 작은 단위로 나누기, 우선 순위 설정, 작업 연기 등 상황에 맞게 유연하게 구동
- 리액트의 가상 DOM 은 사실 간단한 형태의 Value UI, 즉 값을 가지고 있는 UI 를 관리하는 툴에 가깝다
- 컴포넌트에 대한 정보를 1:1 로 가지고 있음

- 실제 리액트 파이버의 내부 코드

```js
function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.refCleanup = null;
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  this.alternate = null;

  // 이하 프로파일러, __DEV__ 코드는 생략
}
```

#### 리액트 파이버 트리

- 이랙트 파이버 트리는 현재 모습을 담은 트리, 작업 중인 상태를 나타내는 workInProgress 트리로 2개가 존재
- 리액트 파이버 작업이 끝나면 리액트는 단순히 포인터(!)만 변경해 workInProgress 를 현재 트리로 변경 (= 더블 버퍼링)
  - 간단히 객체를 깊은 복사 하지 않고, 주소 값만 전달하여 해당 값을 참조하는 방식이라 생각하면 쉽다!
- 더블 버퍼링?
  - 컴퓨터 그래픽에서 나온 개념
  - 리얼 타임으로 새롭게 그리는 작업을 적용하면사용자에게 미쳐 다 그리지 못한 모습을 보일 수 있는 문제 발생
  - 다음으로 그려야 할 것을 백그라운드에서 미리 그리고, 이것이 완성되면 현재 상태를 변경하는 것으로 위의 문제 해결
- 리액트에서도 마찬가지로 작업이 요청 되면 workInProgress 트리를 빌드하고, 빌드가 완료 되면 렌더링으로 UI를 교체한다

\*\* [p. 139] JS 와 C++ 의 객체 개념 이해하기

#### 파이버의 작업 순서

1. beginWork() 함수를 실행하여 파이버 작업 수행, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작
2. 1번 작업이 완료되면 completeWork() 함수로 파이버 작업 완료
3. 2번을 마친 후 파이버 노드에 형제가 있으면 형제로 넘어가서 1, 2 반복
4. 3번 까지 완료시 return 으로 종료

- 1 ~ 4 의 작업으로 트리를 만들고 해당 트리는 current 트리가 된다
- setState 등의 업데이트 요청이 들어오면 workInProgress 트리를 1 ~ 4의 과정을 통해 다시 빌드하기 시작
- 단, 처음부터 다시 생성하는것이 아니라 이미 생성된 파이버에서 업데이트된 props 를 받아서 변경된 부분만 빌드
- 이를 통해 파이버 객체를 계속 만드는 것이 아니라, 바꾸는 형태를 띄므로 효율이 좋아진다
- 기존에는 위의 작업 전체를 스택으로 처리하여 일시 중단, 우선 순위 처리 등이 불가능
- 현재는 파이버 단위로 처리하여 우선 순위, 일시 중단 등이 가능

### 2.2.4 파이버와 가상 DOM

- 파이버는 웹 어플리케이션에서만 사용되는 것이 아니다, 리액트 네이티브에서도 사용
- 단, 파이버의 구조는 동일하며 렌더러가 그리는 방식이 다를 뿐이다

### 2.2.5 정리

- 개발자가 직접 DOM 을 관리하는 수고로움을 리액트 파이버를 통해 관리
- 대규모 웹 어플리케이션을 효율적으로 유지 보수가 가능

## 2.3
