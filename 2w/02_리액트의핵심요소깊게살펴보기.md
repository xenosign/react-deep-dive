# CH2. 리액트의 핵심 요소 깊게 살펴보기

## 2.1 JSX 란?

- 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는데 도움을 주는 문법
- 그대로 사용하면 에러 발생, 사용을 위해서는 순수 JS 로의 트랜스파일이 필요하다(by Babel)

### 2.1.1 JSX 의 정의

- JSXElement, JSXAttributes, JSXChildren, JSXStrings 라는 4가지 컴포넌트로 구성

\*\* [p. 117] 이거 Element 만 왜 단수죠?

#### JSXElement

- JSXOpeningElement : HTML 요소를 여는 요소
- JSXClosingElement : JSXOpeningElement 를 닫는 요소, 반드시 쌍으로 존재 해야함
- JSXSelfClosingElement : 스스로 종료되는 요소의 형태, <input /> 같은 형태
- JSXFragment : 아무런 요소가 없는, 특정 요소들을 감싸는 의미적 요소. < /> 는 존재 불가능 <></> 처럼 쌍으로만 사용 가능

- 요소명은 대문자? : HTML 태그와 구분하기 위해서, 대문자로 시작한다

##### JSXElementName

- JSX 에 이름을 붙일 수 있는 규칙, JS 의 식별자 규칙을 다룬다
- : 를 통해 다른 식별자를 이어주는 것 가능, 단 한번만 가능
  - 가능 : <foo:bar />
  - 불가능 : <foo:bar:baz /> 는 불가능
- . 를 통해 다른 식별자 이어주는 것 가능, 여러번 이어서 사용 가능 단 : 와 혼용은 불가능
  - 가능 : <foo.bar /> <foo.bar.baz />
  - 불가능 : <foo:bar.baz />

##### JSXAttributes

- JSXElement 에 부여할 수 있는 속성을 의미한다, 속성 값이므로 필수 X
- 기본적으로 전개 연산자를 사용하여 JS 에 취급되는 모든 표현식(조건문, 화살표 함수, 할당식)을 전달 가능
- 속성을 키와 값을 짝지어 전달, JSXElementName 과 마찬가지로 : 를 이용하여 키를 사용 가능
  - . 는 왜 안되나요? 아마도 객체등도 전달이 가능한 구조를 가지기에 문법적으로 오류를 일을킬 가능성을 배제하는 것으로 보임
- 할당되는 값은 문자열, 객체, 다른 JSXElement, JSXFragment 등이 전달 가능하다

\*\* [p. 120] 네임스페이스에서 : 는 되는데 . 는 왜 안될까요?
\*\* 아래의 babel 변환 코드 보고 테스트 해볼것

##### JSXChildren

- JSXElement 의 자식 값, 트리 구조를 나타내는 문법이므로 부모 자식을 표현 가능
- JSXChildren 은 JSXChild 를 0개 이상 가질 수 있다(= 없어도 무방하다)
- 문자열을 가질 수 있다. 단, '{', '<', '>', '}' 는 JSX 문법과 혼동이 가능하므로 다르게 전달해야 한다
- 다른 JSX 요소 전달 가능
- JSXFragment 전달 가능

##### JSXStrings

- HTML 에서 사용 가능한 문자열은 전부 사용 가능
- 단, '\' 의 경우 JS 의 특수 문자를 처리하는데 사용하므로 '\' 를 쓰고 싶으면 '\\' 로 써야 함

### 2.1.2 JSX 예제

- 위의 규칙을 만족하면 전부 사용이 가능하다

```jsx
// 사용되는 경우는 없지만 유효한 문법들
cosnt ComponentA = () => {
  return <A.B></A.B>;
}

const ComponentB = () => {
  return <A.B.C></A.B.C>;
}

const ComponentC = () => {
  return <A.B:C></A.B:C>;
}

const ComponentD = () => {
  return <$></$>;
}

const ComponentE = () => {
  return <_></_>;
}
```

### 2.1.3 JSX 는 어떻게 자바스크립트로 변환될까?

- @babel/plugin-transform-react-jsx 플러그인을 사용하여 JSX 를 JS 로 변환

- 변환하기 전 JSX 코드

```jsx
const ComponentA = <A required={true}>Hello World</A>;

const ComponentB = <>Hello World</>;

const ComponentC = {
  <div>
    <span>hello world</span>
  </div>
}
```

- 변환 후 js 코드

```js
"use strict";

var ComponentA = React.createElement(
  A,
  {
    require: true,
  },
  "Hello World"
);

const ComponentB = React.createElement(React.Fragment, null, "Hello, world");

const ComponentC = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello, world")
);
```

#### 직접 해보기

- @babel/standalone 모듈을 사용하여 직접 변환이 가능

```js
import * as Babel from "@babel/standalone";

Babel.registerPlugin(
  "@babel/plugin-transform-react-jsx",
  require("@babel/plugin-transform-react-jsx")
);

const BABEL_CONFIG = {
  presets: [],
  plugins: [
    [
      "@babel/plugin-transform-react-jsx",
      {
        throwIfNamespace: false,
        runtime: "automatic",
        importSource: "custom-jsx-library",
      },
    ],
  ],
};

const SOURCE_CODE = `const ComponentA = <A>안녕하세요.</A>`; // code 변수에 트랜스파일된 결과가 담긴다.

const { code } = Babel.transform(SOURCE_CODE, BABEL_CONFIG);
```

- 이렇게 코드가 변환되는 결과를 알게 된다면 더 효율적인 방법으로 코드 리팩토링이 가능하다
- JSX 반환 값이 결국 React.createElement 로 귀결되므로 코드의 중복 부분을 좀 더 생략이 가능

```js
// ❌ props 여부에 따라 children 만 달라지는 경우
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// ⭕ JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
import { createElement } from "react";
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? "h1" : "span",
    { className: "text" },
    children
  );
}
```

### 2.1.4 정리

- JSXNamespaceName, JSXMemberExpression 은 사용하지 않는다
- 다른 언어도 JSX 를 채용하여 사용 중
- 단, 잘못쓰면 오히려 코드 가독성을 해치니 주의해서 사용해야 함
- JSX 가 어찌 변환되는지를 알고 더 효율적으로 사용하는 것도 중요
